#include <omnetpp.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <stdio.h>
#include <iostream>
#include<stdlib.h>
#include <poll.h>
#include "packets_m.h"
#include "star_m.h"

#define numRouters 16         //TODO: Replace 16 by numRouters

using namespace omnetpp;
using namespace std;

bool fin=false;
char c_src;
FILE *fp_src;
int fromlen_src;
/*register*/ int s_src, ns_src, len_src;
struct sockaddr_un saun_src, fsaun_src;
struct pollfd fds_src;
char const *str_tbs_src = "From Controller!\n";

struct pollfd fds_timer;
char c_timer;
FILE *fp_timer;
int fromlen_timer;
/*register*/ int s_timer, ns_timer, len_timer;
struct sockaddr_un saun_timer, fsaun_timer;
fd_set readset_timer;
char const *str_tbs_timer = "From Controller!\n";
static bool wasExecuted_timer = false;

class controller_src : public cSimpleModule
{
    public:
        int countgen = 0;
        SimTime current_time;
        int countret[numRouters];
        bool hasvalue[numRouters][4][5];
  protected:
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
    int invoke_src();
    void init_socket();
    void timer();
    void generateMessage();
    virtual void finish() override;
};
Define_Module(controller_src);

void controller_src::initialize()
{
    static bool wasExecuted_src = false;
    if (wasExecuted_src)
    {
    //             return;
    }
    else
    {
    	for(int R=0;R<numRouters;R++)
    	{
    	    countret[R]=0;
    	    for(int C=0;C<4;C++)
    	    {
    	        for(int P=0;P<5;P++)
    	            hasvalue[R][C][P]=false;
    	    }
    	}
         wasExecuted_src = true;
         init_socket();
         current_time = simTime() + 100.0;
         cMessage *timer_msg = new cMessage();
         handleMessage(timer_msg);
    }
}

void controller_src::handleMessage(cMessage *msg)
{
    if(msg->arrivedOn("countret"))
    {
        countret[msg->getArrivalGate()->getIndex()]++;
//        EV<<"Count["<<msg->getArrivalGate()->getIndex()<<"] = "<<countret[msg->getArrivalGate()->getIndex()]<<endl;
    }
    else
    {
        if(msg->arrivedOn("timeout"))
        {
            if(check_and_cast<Star *>(msg)->getSent()==true)
            {
                cout<<simTime()<<"s, "<<"YAY:["<<msg->getArrivalGate()->getIndex()<<"]["<<check_and_cast<Star *>(msg)->getC()<<"]["<<check_and_cast<Star *>(msg)->getP()<<"]\n";
                hasvalue[msg->getArrivalGate()->getIndex()][check_and_cast<Star *>(msg)->getC()][check_and_cast<Star *>(msg)->getP()]=true;
            }
        }
        if (((int)(current_time.dbl()) != (int)(simTime().dbl())))
        {
            cout<<simTime()<<"s, -\n";
            if(hasvalue[msg->getArrivalGate()->getIndex()][check_and_cast<Star *>(msg)->getC()][check_and_cast<Star *>(msg)->getP()]==true)
            {

                hasvalue[msg->getArrivalGate()->getIndex()][check_and_cast<Star *>(msg)->getC()][check_and_cast<Star *>(msg)->getP()]=false;
            }
                //            timer();      //TODO: (Correct one), but poll fail
            generateMessage();
            timer();
           	current_time = (int)(simTime().dbl());
        }
        int count_temp = 0;
        for(int i=0;i<numRouters;i++)               
            count_temp += countret[i];
        if((countgen == count_temp) && fin==false)
        {
//            cout<<simTime()<<"s\n";
            cMessage *timer_msg = new cMessage();
            scheduleAt(simTime() + 1.0 /*+ time_slot + double(intuniform(0, 100))/100.0*/ , timer_msg);
        }
    }
    delete msg;
}

void controller_src::init_socket()
{


        const char * ADDR_TIMER = "../socket_timer";
            if ((s_timer = socket(AF_UNIX, SOCK_STREAM , 0)) < 0)
                {
                    perror("server: socket");
                    exit(1);
                }
                saun_timer.sun_family = AF_UNIX;
                strcpy(saun_timer.sun_path, ADDR_TIMER);

                unlink(ADDR_TIMER);
                len_timer = sizeof(saun_timer.sun_family) + strlen(saun_timer.sun_path);



                if (bind(s_timer,(struct sockaddr *) &saun_timer, len_timer) < 0)
                {
                    perror("Timer:server: bind");
                    exit(1);
                }

                if (listen(s_timer, 5) < 0)
                {
                    perror("server: listen");
                    exit(1);
                }

                if ((ns_timer = accept(s_timer, (struct sockaddr *) &fsaun_timer,(socklen_t*) &fromlen_timer)) < 0)
                    {
                        perror("server: accept");
                        exit(1);
                    }
                fp_timer = fdopen(ns_timer, "r");
            FD_ZERO(&readset_timer);
                FD_SET(ns_timer, &readset_timer);

//SRC
                const char * ADDR_SRC = "../socket_src";
                    if ((s_src = socket(AF_UNIX, SOCK_STREAM , 0)) < 0)
                        {
                            perror("server: socket");
                            exit(1);
                        }
                        saun_src.sun_family = AF_UNIX;
                        strcpy(saun_src.sun_path, ADDR_SRC);

                        unlink(ADDR_SRC);
                        len_src = sizeof(saun_src.sun_family) + strlen(saun_src.sun_path);



                        if (bind(s_src,(struct sockaddr *) &saun_src, len_src) < 0)
                        {
                            perror("SRC:server: bind");
                            exit(1);
                        }

                        if (listen(s_src, 5) < 0)
                        {
                            perror("server: listen");
                            exit(1);
                        }

                        if ((ns_src = accept(s_src, (struct sockaddr *) &fsaun_src,(socklen_t*) &fromlen_src)) < 0)
                            {
                                perror("server: accept");
                                exit(1);
                            }
                        fp_src = fdopen(ns_src, "r");


                         fds_src.fd = ns_src;
                         fds_src.events = POLLIN;
                         fds_timer.fd = ns_timer;
                          fds_timer.events = POLLIN;
}

int controller_src::invoke_src()
{
    int output=0;
    while((c_src=fgetc(fp_src))!=EOF)
    {
        if (c_src == '\n')
            break;
        if(c_src == 'q')
        {
            output = -1;
            break;
        }
        output = output*10 + (c_src-48);
    }
        return output;
}

void controller_src::timer()
{
//	cout<<"Timer: Called at t="<<simTime()<<endl;
        int rv_timer;
        if ((wasExecuted_timer == true)/* && (current_time != simTime())*/)
        {
            rv_timer = poll(&fds_timer,1,0);
            if (rv_timer == -1)
            {
                perror("select"); // error occurred in select()
            }
            else if (rv_timer == 0)
            {
        //            printf("Timeout occurred!  \n");
            }
            else
            {
                while ((c_timer = fgetc(fp_timer)) != EOF)
                {
//                    if(c_timer == 'q')
//                    {
//                        cout<<"Simulation End!\n";
//                                        finish();
//                    }
                    if (c_timer == '\n')
                            break;
                }
                ::send(ns_timer, str_tbs_timer, strlen(str_tbs_timer),0);
            }
        }
        else if(wasExecuted_timer == false)
        {
            wasExecuted_timer = true;
            current_time = (int)(simTime().dbl());
        }
}

void controller_src::generateMessage()
{
    //GENERATION
//	cout<<"Generation: Called at t="<<simTime()<<endl;
    int rv,dest,size,num;
    while((rv = poll(&fds_src,1,0))>0)
    {
//		    cout<<"Generation: Successful at t="<<simTime()<<endl;
            num = invoke_src();
            if(num == -1)
            {
                cout<<"Simulation End!\n";
                finish();
                break;
            }
            else
            {
                while(num)
                {
                    size = invoke_src();
                    dest = invoke_src();
                    for(int i = 0; i<size ; i++)
                    {
                        Packet *msg = new Packet();
                        msg->setPid(countgen);
                        msg->setDelay(simTime().dbl());
                        msg->setPacket_type(0);
                        msg->setSize(size);
                        countgen++;
                        if(i==0)
                            msg->setType('h');
                        else if(i==(size-1))        //TODO: Check if it is executed for single packets
                            msg->setType('t');
                        else
                            msg->setType('b');
    //                  EV<<"~~~~~~~~~~~~~~~~~~~~~~~~~ CONTROLLER: Creating new message with ID: "<<msg->getPid()<<" \n";
//                        cout<<"GenFlit("<<msg->getPid()<<") to Router["<<dest<<"] at t="<<simTime()<<"s\n";
                        sendDelayed(msg,0.0/*(double)(intuniform(0,10)/100.0)*/,"out",(dest));
                    }
                    --num;
                }
            }
    }
}

void controller_src::finish()
{
        fin=true;
        cout<<"End Time = "<<simTime()<<"s\n";
       cout<<"FINISH:\nNumber of packets generated = "<<countgen<<"\n";
       int count_temp = 0;
       for(int i=0;i<numRouters;i++)
                   count_temp += countret[i];
       cout<<"FINISH:\nNumber of packets returned = "<<count_temp<<"\n";
       exit(0);
}
