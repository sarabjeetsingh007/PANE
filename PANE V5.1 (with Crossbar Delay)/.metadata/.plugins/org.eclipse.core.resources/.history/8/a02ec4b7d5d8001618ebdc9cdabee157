/*
 * client.cc
 *
 *  Created on: Aug 3, 2016
 *      Author: sarab
 */
#include "packets_m.h"
//#include<string.h>
#include<stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <fstream>
#include <iostream>
#include <omnetpp.h>
#include <poll.h>
#include <sys/ioctl.h>
#include <queue>
#include <stdlib.h>
#include "socket_lib.h"
//#include "test.hpp"
using namespace omnetpp;
using namespace std;
#define numRouters 16
#define numClients 4

struct pollfd fds[numRouters][4][5];

std::queue<int> buff_body[numRouters][5];
std::queue<int> buff_tail[numRouters][5];
bool tail[numRouters][5];

int replyfrombooksim;
std::deque<pair<Packet *, SimTime> > buffer[numRouters][5];
int output_port;

std::queue<int> buff_reply[numRouters][5];

char c;
FILE *fp[numRouters][numClients][5];
//int fromlen;
///*register*/ int s[numRouters][numClients][5], ns[numRouters][numClients][5], len;
//struct sockaddr_un saun[numRouters][numClients][5], fsaun[numRouters][numClients][5];
char myvariable[numRouters][50];
char const *str_tbs = "From Omi!\n";

bool starts_with(const string& s1, const string& s2) {
    return s2.size() <= s1.size() && s1.compare(0, s2.size(), s2) == 0;
}

namespace patch
{
    template < typename T > std::string to_string( const T& n )
    {
        std::ostringstream stm ;
        stm << n ;
        return stm.str() ;
    }
}

double k[numClients]={0.0,0.0,0.0,0.0};
//double k[numClients]={0.3,0.3,0.3,0.3};
//double k[numClients]={0.2,0.3,0.6,0.5};

class mod : public cSimpleModule
{
    private:
       Packet *somemsg[5];
       Packet *ackmsg[5];
       cMessage *timer_msg;
       bool hasvalue0[5];
       int replyfrombooksim0[5];
       bool hasvalue[5];
       int replyfrombooksim1[5];
       bool ack[5];
       double time_slot;
       SimTime current_time[5];
    public:
       mod();
       virtual ~mod();
//       int port_value[5];
    protected:
        virtual void initialize() override;
        void init_socket();
        void notifyBookSim(int id, int port);
        int replyfromBookSim(int port);
        virtual void handleMessage(cMessage *msg) override;
        virtual void finish() override;
};
Define_Module(mod);

mod::mod()
{
    for(int i = 0; i < 5 ; i++)
    {
        ack[i]=true;
        somemsg[i]=nullptr;
        ackmsg[i]=nullptr;
        hasvalue[i]=false;
        hasvalue0[i]=false;
    }
}

mod::~mod()
{
    for(int i = 0; i < 5; i++)
    {
        delete somemsg[i];
        delete ackmsg[i];
//        delete timer_msg[i];
    }
    delete timer_msg;
}

void mod::initialize()
{
    static bool wasExecuted_router = false;
         if (wasExecuted_router)
         {
//             return;
         }
         else
         {
             wasExecuted_router = true;
             init_socket();
         }

         string line;
          ifstream myfile ("config.txt");
          if(myfile.is_open())
          {
              while ( getline (myfile,line) )
              {
                  if(starts_with(line,"time_slot0"))
                  {
                      if(this->getIndex()==0)
                      {
                          line.erase (0,12);
                          std::string::size_type sz;
                          time_slot = std::stoi(line,&sz);
                          EV<<"Client 0 time_slot = "<<time_slot<<" s\n";
                          //break;
                      }
                  }
                  else if(starts_with(line,"time_slot1"))
                  {
                        if(this->getIndex()==1)
                        {
                            line.erase (0,12);
                            std::string::size_type sz;
                            time_slot = std::stoi(line,&sz);
                            EV<<"Client 1 time_slot = "<<time_slot<<" s\n";
                            //break;
                        }
                  }
                  else if(starts_with(line,"time_slot2"))
                  {
                        if(this->getIndex()==2)
                        {
                            line.erase (0,12);
                            std::string::size_type sz;
                            time_slot = std::stoi(line,&sz);
                            EV<<"Client 2 time_slot = "<<time_slot<<" s\n";
                            //break;
                        }
                  }
                  else if(starts_with(line,"time_slot3"))
                    {
                          if(this->getIndex()==3)
                          {
                              line.erase (0,12);
                              std::string::size_type sz;
                              time_slot = std::stoi(line,&sz);
                              EV<<"Client 3 time_slot = "<<time_slot<<" s\n";
                              //break;
                          }
                    }
            }
            myfile.close();
          }
          for(int i = 0; i < 5; i++)
          {
              ack[i] = true;
          }
}
void mod::handleMessage(cMessage *msg)
{
        if(this->getIndex()==3)     //TODO: Validate
        {
            for(int i=0;i<5;i++)
                ack[i]= true;
        }
        if(msg->arrivedOn("in") && (check_and_cast<Packet *>(msg)->getPid()==-1))
        {
            finish();
            return;
        }
        if(msg->arrivedOn("Ack_in"))        //*Sarab
        {
            ackmsg[msg->getArrivalGate()->getIndex()] = check_and_cast<Packet *>(msg);
            EV<<"~~~~~~~~~~~~~~~~~~~~~~~~~ "<<this->getParentModule()->getFullName()<<"."<<this->getFullName()<<": Received, Acknowledgement, ID: "<<ackmsg[msg->getArrivalGate()->getIndex()]->getPid()<<", Port:"<<msg->getArrivalGate()->getIndex()<<" \n";
                ack[msg->getArrivalGate()->getIndex()] = true;
                cMessage *tt_msg = new cMessage();
                 sendDelayed(tt_msg,0.0,"poll");
                 delete ackmsg[msg->getArrivalGate()->getIndex()];
                return;
        }
        if(msg->arrivedOn("in"))
        {
            if(this->getIndex() == 0)
            {
                buffer[this->getParentModule()->getIndex()][msg->getArrivalGate()->getIndex()].push_back(make_pair(check_and_cast<Packet *>(msg),simTime()));
//                cout<<"pushed in buffer---------["<<this->getParentModule()->getIndex()<<"]["<<msg->getArrivalGate()->getIndex()<<"]->ID:"<<(check_and_cast<Packet *>(msg))->getPid()<<endl;
//                        return ;
            }
            somemsg[msg->getArrivalGate()->getIndex()] = check_and_cast<Packet *>(msg);
            notifyBookSim(somemsg[msg->getArrivalGate()->getIndex()]->getPid(),msg->getArrivalGate()->getIndex());
            EV<<"~~~~~~~~~~~~~~~~~~~~~~~~~ "<<this->getParentModule()->getFullName()<<"."<<this->getFullName()<<":  Received, Message, ID: "<<somemsg[msg->getArrivalGate()->getIndex()]->getPid()<<", Port:"<<msg->getArrivalGate()->getIndex()<<" \n";
            current_time[msg->getArrivalGate()->getIndex()] = simTime();
            if(this->getIndex() == 3)
            {
                if(this->getParentModule()->getIndex()==14 && msg->getArrivalGate()->getIndex()==1)
                cout<<somemsg[msg->getArrivalGate()->getIndex()]->getPid()<<endl;
                tail[this->getParentModule()->getIndex()][msg->getArrivalGate()->getIndex()]=true;
            }
        }

//        if(timer_msg->isSelfMessage() && timer_msg->getArrivalModule()==msg->getArrivalModule())
//            cancelAndDelete(timer_msg);
        for(int port = 0;port < 5; port++)
        {
              if(this->getIndex()==3)
              {
                  if(((simTime() - current_time[port]) >= time_slot) && (somemsg[port]!=nullptr))
                  {
                      if(hasvalue[port]==false)
                      {
                          if((replyfrombooksim1[port] = replyfromBookSim(port)) >= 0)
                              hasvalue[port] = true;
                      }
                       if((hasvalue[port]==true) && (ack[replyfrombooksim1[port] - 1]==true))
                       {
//                               cMessage *tt_msg = new cMessage();
//                                sendDelayed(tt_msg,0.0,"poll");

                             if(tail[this->getParentModule()->getIndex()][port] == true)
                             {
                                 tail[this->getParentModule()->getIndex()][port]=false;
                                 sendDelayed(somemsg[port],k[this->getIndex()]/* (double)(intuniform(0,k)/100.0)*/,"out",(replyfrombooksim1[port]-1));
                                 if(somemsg[port]->getSize()==1)
                                 {
                                       hasvalue[port]=false;
                                       ack[replyfrombooksim1[port] - 1] = false;
                                       current_time[port] = simTime();
                                       Packet *ack_msg= new Packet();
                                       ack_msg->setPid(somemsg[port]->getPid());
                                       ack_msg->setPacket_type(1);
                                       ack_msg->setKind(1);
                                           sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                       somemsg[port] = nullptr;
                                       delete somemsg[port];
                                       tail[this->getParentModule()->getIndex()][port]=true;
                                       //return/break;
                                 }
                             }
                             if(tail[this->getParentModule()->getIndex()][port] == false)
                             {
                                 while(!buff_body[this->getParentModule()->getIndex()][port].empty())
                                  {
//                                     if(simTime() == current_time[port])
//                                         cout<<somemsg[port]->getPid()<<","<<buff_body[this->getParentModule()->getIndex()][port].front()<<endl;
                                     somemsg[port]=nullptr;
                                     delete somemsg[port];
                                     somemsg[port]= new Packet();
                                     somemsg[port]->setPid(buff_body[this->getParentModule()->getIndex()][port].front());
                                     somemsg[port]->setDelay(simTime().dbl());
                                     somemsg[port]->setPacket_type(0);
                                     somemsg[port]->setType('b');
                                         notifyBookSim(somemsg[port]->getPid(),port);
                                         sendDelayed(somemsg[port],k[this->getIndex()],"out",(replyfrombooksim1[port]-1));
                                         if((!buff_tail[this->getParentModule()->getIndex()][port].empty()) && (buff_tail[this->getParentModule()->getIndex()][port].front() == (buff_body[this->getParentModule()->getIndex()][port].front() + 1)))
                                         {
                                             buff_body[this->getParentModule()->getIndex()][port].pop();
                                              somemsg[port]=nullptr;
                                              delete somemsg[port];
                                              somemsg[port]= new Packet();
                                              somemsg[port]->setPid(buff_tail[this->getParentModule()->getIndex()][port].front());
                                              somemsg[port]->setDelay(simTime().dbl());
                                              somemsg[port]->setPacket_type(0);
                                              somemsg[port]->setType('t');
                                                  notifyBookSim(somemsg[port]->getPid(),port);
                                             sendDelayed(somemsg[port],k[this->getIndex()],"out",(replyfrombooksim1[port]-1));
                                             buff_tail[this->getParentModule()->getIndex()][port].pop();
                                                  hasvalue[port]=false;
                                                  ack[replyfrombooksim1[port] - 1] = false;
                                                  current_time[port] = simTime();
                                                  Packet *ack_msg= new Packet();
                                                  ack_msg->setPid(somemsg[port]->getPid());
                                                  ack_msg->setPacket_type(1);
                                                  ack_msg->setKind(1);
                                                      sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                                  somemsg[port] = nullptr;
                                                  delete somemsg[port];
                                             tail[this->getParentModule()->getIndex()][port]=true;
                                             break;
                                         }
                                         else
                                             buff_body[this->getParentModule()->getIndex()][port].pop();
                                  }
                                  if((tail[this->getParentModule()->getIndex()][port] == false) && (!buff_tail[this->getParentModule()->getIndex()][port].empty()))
                                  {
                                        somemsg[port]=nullptr;
                                        delete somemsg[port];
                                        somemsg[port]= new Packet();
                                        somemsg[port]->setPid(buff_tail[this->getParentModule()->getIndex()][port].front());
                                        somemsg[port]->setDelay(simTime().dbl());
                                        somemsg[port]->setPacket_type(0);
                                        somemsg[port]->setType('t');
                                            notifyBookSim(somemsg[port]->getPid(),port);
                                      sendDelayed(somemsg[port],k[this->getIndex()],"out",(replyfrombooksim1[port]-1));
                                      buff_tail[this->getParentModule()->getIndex()][port].pop();
                                            hasvalue[port]=false;
                                            ack[replyfrombooksim1[port] - 1] = false;
                                            current_time[port] = simTime();
                                            Packet *ack_msg= new Packet();
                                            ack_msg->setPid(somemsg[port]->getPid());
                                            ack_msg->setPacket_type(1);
                                            ack_msg->setKind(1);
                                                sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                            somemsg[port] = nullptr;
                                            delete somemsg[port];
                                       tail[this->getParentModule()->getIndex()][port]=true;
                                  }
                             }
                       }
                  }
              }
              else if(this->getIndex()==0)
              {
                    if((ack[port]==true) && (buffer[this->getParentModule()->getIndex()][port].size()>0) )
                    {
                        if(hasvalue0[port]==false && buff_reply[this->getParentModule()->getIndex()][port].empty()==true)
                        {
                            if((replyfrombooksim0[port] = replyfromBookSim(port)) >= 0)
                                hasvalue0[port] = true;
                        }
                        else if(hasvalue0[port]==false && buff_reply[this->getParentModule()->getIndex()][port].empty()==false)
                        {
                            hasvalue0[port] = true;
                            replyfrombooksim0[port] = buff_reply[this->getParentModule()->getIndex()][port].front();
//                            cout<<"Router["<<this->getParentModule()->getIndex()<<"][0]["<<port<<"]->"<<replyfrombooksim0[port]<<"<-F\n";
                            buff_reply[this->getParentModule()->getIndex()][port].pop();
                        }
                        if(hasvalue0[port]==true)
                        {
                            std::deque<pair<Packet *, SimTime> >::iterator iter = buffer[this->getParentModule()->getIndex()][port].begin();
                            while(iter != buffer[this->getParentModule()->getIndex()][port].end())
                            {
                                if(iter->first->getPid()==replyfrombooksim0[port])
                                {
                                    if(((simTime() - iter->second) >= time_slot))   //TODO: Check if integrity maintained! (simTime()- cuurent_time)
                                    {
                                        somemsg[port] = iter->first;
                                        hasvalue0[port]=false;
        //                              cout<<"-Acknowledgement["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->ID("<<somemsg[port]->getPid()<<")\n";
    //                                  current_time[port] = simTime();
                                        Packet *ack_msg= new Packet();
                                          ack_msg->setPid(somemsg[port]->getPid());
                                          ack_msg->setPacket_type(1);
                                          ack_msg->setKind(1);
                                          if(somemsg[port]->getType()=='b')
                                          {
                                              buff_body[this->getParentModule()->getIndex()][port].push(somemsg[port]->getPid());
                                              somemsg[port] = nullptr;
                                              delete somemsg[port];
                                              buffer[this->getParentModule()->getIndex()][port].erase(iter);
                                              sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                              return;
                                          }
                                          else if(somemsg[port]->getType()=='t')
                                          {
                                              buff_tail[this->getParentModule()->getIndex()][port].push(somemsg[port]->getPid());
                                              somemsg[port] = nullptr;
                                              delete somemsg[port];
                                              buffer[this->getParentModule()->getIndex()][port].erase(iter);
                                              sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                              return;
                                          }
//                                        current_time[port] = simTime();
                                        ack[port] = false;
                                        sendDelayed(somemsg[port],k[this->getIndex()]/* (double)(intuniform(0,k)/100.0)*/,"out",port);
                                        somemsg[port] = nullptr;
                                        delete somemsg[port];
                                        sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                        buffer[this->getParentModule()->getIndex()][port].erase(iter);
                                    }
                                    break;
                                }
                                iter++;
                            }
                        }
                    }
              }
              else
              {
                  if((ack[port]==true) && ((simTime() - current_time[port]) >= time_slot) && (somemsg[port]!=nullptr) && ((replyfrombooksim = replyfromBookSim(port)) >= 0) )
                  {
//                              cout<<"-Acknowledgement["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->ID("<<somemsg[port]->getPid()<<")\n";
//                                  current_time[port] = simTime();
                              Packet *ack_msg= new Packet();
                                ack_msg->setPid(somemsg[port]->getPid());
                                ack_msg->setPacket_type(1);
                                ack_msg->setKind(1);
                              current_time[port] = simTime();
                              ack[port] = false;
                              sendDelayed(somemsg[port],k[this->getIndex()]/* (double)(intuniform(0,k)/100.0)*/,"out",port);
                              somemsg[port] = nullptr;
                              delete somemsg[port];
                              sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                  }
              }
              if(!msg->isSelfMessage())
              {
                  if(this->getIndex()==0)
                  {
                      if((buffer[this->getParentModule()->getIndex()][0].size()>0) || (buffer[this->getParentModule()->getIndex()][1].size()>0) ||(buffer[this->getParentModule()->getIndex()][2].size()>0) ||(buffer[this->getParentModule()->getIndex()][3].size()>0) ||(buffer[this->getParentModule()->getIndex()][4].size()>0))
                      {
                          timer_msg = new cMessage();
                          cMessage *tt_msg = new cMessage();
                          tt_msg->setKind(4);
                          sendDelayed(tt_msg,0.0,"poll");
                          scheduleAt(simTime() + 1.0 /*+ time_slot + double(intuniform(0, 100))/100.0*/ , timer_msg);
                      }
                  }
                  else
                  {
                      if(somemsg[0] || somemsg[1] ||somemsg[2] ||somemsg[3] ||somemsg[4])
                        {
                            timer_msg = new cMessage();
                            cMessage *tt_msg = new cMessage();
                            tt_msg->setKind(4);
                            sendDelayed(tt_msg,0.0,"poll");
                            scheduleAt(simTime() + 1.0 /*+ time_slot + double(intuniform(0, 100))/100.0*/ , timer_msg);
                        }
                  }
              }
        }
        if(msg->isSelfMessage())
        {
            if(this->getIndex()==0)
              {
                  if((buffer[this->getParentModule()->getIndex()][0].size()>0) || (buffer[this->getParentModule()->getIndex()][1].size()>0) ||(buffer[this->getParentModule()->getIndex()][2].size()>0) ||(buffer[this->getParentModule()->getIndex()][3].size()>0) ||(buffer[this->getParentModule()->getIndex()][4].size()>0))
                  {
                      timer_msg = new cMessage();
                      cMessage *tt_msg = new cMessage();
                      tt_msg->setKind(4);
                      sendDelayed(tt_msg,0.0,"poll");
                      scheduleAt(simTime() + 1.0 /*+ time_slot + double(intuniform(0, 100))/100.0*/ , timer_msg);
                  }
              }
              else
              {
                  if(somemsg[0] || somemsg[1] ||somemsg[2] ||somemsg[3] ||somemsg[4])
                    {
                        timer_msg = new cMessage();
                        cMessage *tt_msg = new cMessage();
                        tt_msg->setKind(4);
                        sendDelayed(tt_msg,0.0,"poll");
                        scheduleAt(simTime() + 1.0 /*+ time_slot + double(intuniform(0, 100))/100.0*/ , timer_msg);
                    }
              }
        }
}

void mod::init_socket()
{
    int R,C,P;
    assignsocklist();
    for(R=0;R<numRouters;R++)
    {
        for(C=0;C<numClients;C++)
        {
            for(P=0;P<5;P++)
            {
                create_socket(R,C,P);
                fp[R][C][P] = fdopen(getfd(R,C,P), "r");
                fds[R][C][P].fd = getfd(R,C,P);                  //FDS-Client
                fds[R][C][P].events = POLLIN;
            }
        }
    }
}


int mod::replyfromBookSim(int port)
{
    int rv,output=0;
//    if(this->getIndex()==0 && this->getParentModule()->getIndex()==7 && port==1)
//        cout<<"Router["<<this->getParentModule()->getIndex()<<"][0]["<<port<<"]->CAllED at "<<simTime()<<endl;
    rv = poll(&fds[this->getParentModule()->getIndex()][this->getIndex()][port],1,0);
    if(rv > 0)
    {
        while ((c = fgetc(fp[this->getParentModule()->getIndex()][this->getIndex()][port])) != EOF)
        {
            if (c == '\n')
                break;
            else
                output = output*10 + (c - 48);//int(c) - 48;
        }
    }
    if((this->getIndex() == 3) && (rv > 0))
    {
          return output;
    }
    else if((this->getIndex() == 0) && (rv > 0))
    {
        int output1=0;
        while ((c = fgetc(fp[this->getParentModule()->getIndex()][this->getIndex()][port])) != '*')
        {
            if (c == '\n')
            {
//                cout<<"Router["<<this->getParentModule()->getIndex()<<"][0]["<<port<<"]->"<<output1<<"<-T\n";
                buff_reply[this->getParentModule()->getIndex()][port].push(output1);
                output1=0;
            }
            else
                output1 = output1*10 + (c - 48);//int(c) - 48;
        }
        return output;
    }
    else
    {
            return (rv-1);
    }
}

void mod::notifyBookSim( int id, int port )
{
        if(this->getIndex()==3 && this->getParentModule()->getIndex()==14)
            cout<<simTime()<<"s->["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->ID("<<id<<")\n";
        std::string myvariable_router = patch::to_string(id);
        myvariable_router.append("\n");
        str_tbs = &myvariable_router[0];
        ::send(getfd(this->getParentModule()->getIndex(),this->getIndex(),port), str_tbs, strlen(str_tbs),0);
        if(this->getIndex()==0)
        {
            sethasvalue(true,this->getParentModule()->getIndex(),this->getIndex(),port);
        }
}

void mod::finish()
{
//    delete timer_msg;
//    close(s);
//    EV<<"finishing the simulation\n";
}
