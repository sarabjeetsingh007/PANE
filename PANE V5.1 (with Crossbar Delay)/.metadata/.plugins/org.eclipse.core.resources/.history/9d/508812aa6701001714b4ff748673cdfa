/*
 * client.cc
 *
 *  Created on: Aug 3, 2016
 *      Author: sarab
 */
#include "packets_m.h"
//#include<string.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <fstream>
#include <iostream>
#include <omnetpp.h>
#include <poll.h>
#include <sys/ioctl.h>
#include <queue>
#include <stdlib.h>
#include "socket_lib.h"
//#include "test.hpp"
using namespace omnetpp;
using namespace std;
#define numRouters 16
#define numClients 4
#define numVCs 4

struct pollfd fds[numRouters][4][5];

std::queue<int> buff_body[numRouters][5][numVCs];
std::queue<int> buff_tail[numRouters][5][numVCs];
bool tail[numRouters][5];

int replyfrombooksim;
std::deque<pair<Packet *, SimTime> > buffer[numRouters][5];
int output_port;

std::queue<pair<int, int> > buff_reply[numRouters][5];

char c;
FILE *fp[numRouters][numClients][5];
char myvariable[numRouters][50];
char const *str_tbs = "From Omi!\n";

//FILE *fp2[numRouters][numClients][5];   //Toy
//struct pollfd fds2[numRouters][4][5];   //Toy

bool starts_with(const string& s1, const string& s2) {
    return s2.size() <= s1.size() && s1.compare(0, s2.size(), s2) == 0;
}

namespace patch
{
    template < typename T > std::string to_string( const T& n )
    {
        std::ostringstream stm ;
        stm << n ;
        return stm.str() ;
    }
}

double k[numClients]={0.0,0.0,0.0,0.0};     //Time Delays

class mod : public cSimpleModule
{
    private:
       Packet *somemsg[5];
       Packet *ackmsg[5];
       cMessage *timer_msg;
       bool hasvalue0[5];
       int replyfrombooksim0[5];
       int vc[5];
       int lastbody[5];
       bool hasvalue[5];
       int replyfrombooksim1[5];
       bool ack[5];
       double time_slot;
       SimTime current_time[5];
    public:
       mod();
       virtual ~mod();
//       int port_value[5];
    protected:
        virtual void initialize() override;
        void init_socket();
        void notifyBookSim(int id, int port);
        int replyfromBookSim(int port);
        virtual void handleMessage(cMessage *msg) override;
        virtual void finish() override;
};
Define_Module(mod);

mod::mod()
{
    for(int i = 0; i < 5 ; i++)
    {
        ack[i]=true;
        somemsg[i]=nullptr;
        ackmsg[i]=nullptr;
        hasvalue[i]=false;
        hasvalue0[i]=false;
    }
}

mod::~mod()
{
    for(int i = 0; i < 5; i++)
    {
        delete somemsg[i];
        delete ackmsg[i];
//        delete timer_msg[i];
    }
    delete timer_msg;
}

void mod::initialize()
{
    static bool wasExecuted_router = false;
         if (wasExecuted_router)
         {
//             return;
         }
         else
         {
             wasExecuted_router = true;
             init_socket();
         }

         string line;
          ifstream myfile ("config.txt");
          if(myfile.is_open())
          {
              while ( getline (myfile,line) )
              {
                  if(starts_with(line,"time_slot0"))
                  {
                      if(this->getIndex()==0)
                      {
                          line.erase (0,12);
                          std::string::size_type sz;
                          time_slot = std::stoi(line,&sz);
                          EV<<"Client 0 time_slot = "<<time_slot<<" s\n";
                          //break;
                      }
                  }
                  else if(starts_with(line,"time_slot1"))
                  {
                        if(this->getIndex()==1)
                        {
                            line.erase (0,12);
                            std::string::size_type sz;
                            time_slot = std::stoi(line,&sz);
                            EV<<"Client 1 time_slot = "<<time_slot<<" s\n";
                            //break;
                        }
                  }
                  else if(starts_with(line,"time_slot2"))
                  {
                        if(this->getIndex()==2)
                        {
                            line.erase (0,12);
                            std::string::size_type sz;
                            time_slot = std::stoi(line,&sz);
                            EV<<"Client 2 time_slot = "<<time_slot<<" s\n";
                            //break;
                        }
                  }
                  else if(starts_with(line,"time_slot3"))
                    {
                          if(this->getIndex()==3)
                          {
                              line.erase (0,12);
                              std::string::size_type sz;
                              time_slot = std::stoi(line,&sz);
                              EV<<"Client 3 time_slot = "<<time_slot<<" s\n";
                              //break;
                          }
                    }
            }
            myfile.close();
          }
          for(int i = 0; i < 5; i++)
          {
              ack[i] = true;
          }
}
void mod::handleMessage(cMessage *msg)
{
        if(this->getIndex()==3)     //TODO: Validate
        {
            for(int i=0;i<5;i++)
                ack[i]= true;
        }
        if(msg->arrivedOn("in") && (check_and_cast<Packet *>(msg)->getPid()==-1))
        {
            finish();
            return;
        }
        if(msg->arrivedOn("Ack_in"))        //*Sarab
        {
            ackmsg[msg->getArrivalGate()->getIndex()] = check_and_cast<Packet *>(msg);
//            EV<<"~~~~~~~~~~~~~~~~~~~~~~~~~ "<<this->getParentModule()->getFullName()<<"."<<this->getFullName()<<": Received, Acknowledgement, ID: "<<ackmsg[msg->getArrivalGate()->getIndex()]->getPid()<<", Port:"<<msg->getArrivalGate()->getIndex()<<" \n";
                ack[msg->getArrivalGate()->getIndex()] = true;
                if((int)(getcontrollertime().dbl()) != (int)(simTime().dbl()))
                {
                    setcontrollertime(simTime());
                    cMessage *tt_msg = new cMessage();
                    sendDelayed(tt_msg,0.0,"poll");
                }
                 delete ackmsg[msg->getArrivalGate()->getIndex()];
                return;
        }
        if(msg->arrivedOn("in"))
        {
            if(this->getIndex() == 0)
            {
                buffer[this->getParentModule()->getIndex()][msg->getArrivalGate()->getIndex()].push_back(make_pair(check_and_cast<Packet *>(msg),simTime()));
            }
            somemsg[msg->getArrivalGate()->getIndex()] = check_and_cast<Packet *>(msg);
            notifyBookSim(somemsg[msg->getArrivalGate()->getIndex()]->getPid(),msg->getArrivalGate()->getIndex());
//            EV<<"~~~~~~~~~~~~~~~~~~~~~~~~~ "<<this->getParentModule()->getFullName()<<"."<<this->getFullName()<<":  Received, Message, ID: "<<somemsg[msg->getArrivalGate()->getIndex()]->getPid()<<", Port:"<<msg->getArrivalGate()->getIndex()<<" \n";
            current_time[msg->getArrivalGate()->getIndex()] = simTime();
            if(this->getIndex() == 3)
            {
                tail[this->getParentModule()->getIndex()][msg->getArrivalGate()->getIndex()] = true;//Multiple Vcs
            }
        }

        for(int port = 0;port < 5; port++)
        {
              if(this->getIndex()==3)
              {
                  if(((simTime() - current_time[port]) >= time_slot) && (somemsg[port]!=nullptr))
                  {
//                      cout<<simTime()<<"s:1:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]\n";
                      if(hasvalue[port]==false)
                      {
//                          cout<<simTime()<<"s:2(SockRead):["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]\n";
                          if((replyfrombooksim1[port] = replyfromBookSim(port)) >= 0)
                              hasvalue[port] = true;
                      }
                       if((hasvalue[port]==true) && (ack[replyfrombooksim1[port] - 1]==true))
                       {
//                           cout<<simTime()<<"s:2:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]\n";
                             if(tail[this->getParentModule()->getIndex()][port] == true)
                             {
//                                 cout<<simTime()<<"s:Head:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]\n";
                                 tail[this->getParentModule()->getIndex()][port] = false;
                                 vc[port] = somemsg[port]->getVc();
                                 sendDelayed(somemsg[port],k[this->getIndex()]/* (double)(intuniform(0,k)/100.0)*/,"out",(replyfrombooksim1[port]-1));
                                 lastbody[port] = somemsg[port]->getPid();//Check
                                 if(somemsg[port]->getSize()==1)
                                 {
                                       hasvalue[port]=false;
                                       ack[replyfrombooksim1[port] - 1] = false;
                                       current_time[port] = simTime();
                                       Packet *ack_msg= new Packet();
                                       ack_msg->setPid(somemsg[port]->getPid());
                                       ack_msg->setPacket_type(1);
                                       ack_msg->setKind(1);
                                           sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                       somemsg[port] = nullptr;
                                       delete somemsg[port];
                                       tail[this->getParentModule()->getIndex()][port] = true;
                                 }
                             }
                             if(tail[this->getParentModule()->getIndex()][port] == false)
                             {
//                                 cout<<simTime()<<"s:3:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]\n";
                                 while(!buff_body[this->getParentModule()->getIndex()][port][vc[port]].empty() && (buff_body[this->getParentModule()->getIndex()][port][vc[port]].front()== (lastbody[port] + 1)))
                                  {
                                     somemsg[port]=nullptr;
                                     delete somemsg[port];
                                     somemsg[port]= new Packet();
                                     somemsg[port]->setPid(buff_body[this->getParentModule()->getIndex()][port][vc[port]].front());
                                     somemsg[port]->setDelay(simTime().dbl());
                                     somemsg[port]->setPacket_type(0);
                                     somemsg[port]->setType('b');
                                     lastbody[port] = buff_body[this->getParentModule()->getIndex()][port][vc[port]].front();
                                         notifyBookSim(somemsg[port]->getPid(),port);
//                                         cout<<"s:(Body) R,C,P:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->ID:"<<somemsg[port]->getPid()<<"\n";
                                         sendDelayed(somemsg[port],k[this->getIndex()],"out",(replyfrombooksim1[port]-1));
                                         if((!buff_tail[this->getParentModule()->getIndex()][port][vc[port]].empty()) && (buff_tail[this->getParentModule()->getIndex()][port][vc[port]].front() == (lastbody[port] + 1)))
                                         {
                                             buff_body[this->getParentModule()->getIndex()][port][vc[port]].pop();
                                              somemsg[port]=nullptr;
                                              delete somemsg[port];
                                              somemsg[port]= new Packet();
                                              somemsg[port]->setPid(buff_tail[this->getParentModule()->getIndex()][port][vc[port]].front());
                                              somemsg[port]->setDelay(simTime().dbl());
                                              somemsg[port]->setPacket_type(0);
                                              somemsg[port]->setType('t');
                                                  notifyBookSim(somemsg[port]->getPid(),port);
//                                                  cout<<"s:(Tail-1) R,C,P:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->ID:"<<somemsg[port]->getPid()<<"\n";
                                             sendDelayed(somemsg[port],k[this->getIndex()],"out",(replyfrombooksim1[port]-1));
                                             buff_tail[this->getParentModule()->getIndex()][port][vc[port]].pop();
                                                  hasvalue[port]=false;
                                                  ack[replyfrombooksim1[port] - 1] = false;
                                                  current_time[port] = simTime();
                                                  Packet *ack_msg= new Packet();
                                                  ack_msg->setPid(somemsg[port]->getPid());
                                                  ack_msg->setPacket_type(1);
                                                  ack_msg->setKind(1);
                                                      sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                                  somemsg[port] = nullptr;
                                                  delete somemsg[port];
                                             tail[this->getParentModule()->getIndex()][port] = true;
                                             break;
                                         }
                                         else
                                             buff_body[this->getParentModule()->getIndex()][port][vc[port]].pop();
                                  }
                                  if((tail[this->getParentModule()->getIndex()][port] == false) && (!buff_tail[this->getParentModule()->getIndex()][port][vc[port]].empty()) && (buff_tail[this->getParentModule()->getIndex()][port][vc[port]].front() == (lastbody[port] + 1)))
                                  {
                                        somemsg[port]=nullptr;
                                        delete somemsg[port];
                                        somemsg[port]= new Packet();
                                        somemsg[port]->setPid(buff_tail[this->getParentModule()->getIndex()][port][vc[port]].front());
                                        somemsg[port]->setDelay(simTime().dbl());
                                        somemsg[port]->setPacket_type(0);
                                        somemsg[port]->setType('t');
                                            notifyBookSim(somemsg[port]->getPid(),port);
//                                            cout<<"s:(Tail-2) R,C,P:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->ID:"<<somemsg[port]->getPid()<<"\n";
                                      sendDelayed(somemsg[port],k[this->getIndex()],"out",(replyfrombooksim1[port]-1));
                                      buff_tail[this->getParentModule()->getIndex()][port][vc[port]].pop();
                                            hasvalue[port]=false;
                                            ack[replyfrombooksim1[port] - 1] = false;
                                            current_time[port] = simTime();
                                            Packet *ack_msg= new Packet();
                                            ack_msg->setPid(somemsg[port]->getPid());
                                            ack_msg->setPacket_type(1);
                                            ack_msg->setKind(1);
                                                sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                            somemsg[port] = nullptr;
                                            delete somemsg[port];
                                       tail[this->getParentModule()->getIndex()][port] = true;
                                  }
                             }
                       }
                  }
              }
              else if(this->getIndex()==0)
              {
                    if(/*(ack[port]==true) && */(buffer[this->getParentModule()->getIndex()][port].size()>0) )
                    {
                        if(hasvalue0[port]==false /*&& buff_reply[this->getParentModule()->getIndex()][port].empty()==true*/)
                        {
                            if((replyfrombooksim0[port] = replyfromBookSim(port)) >= 0)
                            {
                                cout<<"\n\t\tSOMETHING WRONG\n";
                                hasvalue0[port] = true;
                            }
                        }
                        if(hasvalue0[port]==false && buff_reply[this->getParentModule()->getIndex()][port].empty()==false)
                        {
                            hasvalue0[port] = true;
                            replyfrombooksim0[port] = buff_reply[this->getParentModule()->getIndex()][port].front().first;
                            vc[port] = buff_reply[this->getParentModule()->getIndex()][port].front().second;
                            buff_reply[this->getParentModule()->getIndex()][port].pop();
                        }
                        if(hasvalue0[port]==true)
                        {
                            std::deque<pair<Packet *, SimTime> >::iterator iter = buffer[this->getParentModule()->getIndex()][port].begin();
                            while(iter != buffer[this->getParentModule()->getIndex()][port].end())
                            {
                                if(iter->first->getPid()==replyfrombooksim0[port])
                                {
                                    if(((simTime() - iter->second) >= time_slot))
                                    {
                                        if(iter->first->getType()=='h')         //TODO: Remove Redundancy of HBT
                                        {
                                            if(ack[port]==true)
                                            {
                                                somemsg[port] = iter->first;
                                                somemsg[port]->setVc(vc[port]);
                                                hasvalue0[port]=false;
                                                Packet *ack_msg= new Packet();
                                                  ack_msg->setPid(somemsg[port]->getPid());
                                                  ack_msg->setPacket_type(1);
                                                  ack_msg->setKind(1);
                                                ack[port] = false;
                                                sendDelayed(somemsg[port],k[this->getIndex()]/* (double)(intuniform(0,k)/100.0)*/,"out",port);
                                                somemsg[port] = nullptr;
                                                delete somemsg[port];
                                                sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                                                buffer[this->getParentModule()->getIndex()][port].erase(iter);
                                            }
                                        }
                                        else
                                        {
                                            somemsg[port] = iter->first;
                                            somemsg[port]->setVc(vc[port]);
                                            hasvalue0[port]=false;
        //                                  current_time[port] = simTime();
                                            Packet *ack_msg= new Packet();
                                              ack_msg->setPid(somemsg[port]->getPid());
                                              ack_msg->setPacket_type(1);
                                              ack_msg->setKind(1);
                                              if(somemsg[port]->getType()=='b')
                                              {
                                                  cout<<simTime()<<"s:Added to Body["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]:"<<somemsg[port]->getPid()<<"\n";
                                                  buff_body[this->getParentModule()->getIndex()][port][vc[port]].push(somemsg[port]->getPid());
                                                  somemsg[port] = nullptr;
                                                  delete somemsg[port];
                                                  buffer[this->getParentModule()->getIndex()][port].erase(iter);
                                                  sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);     //TODO: Check if needed to send ack
                                                  return;
                                              }
                                              else if(somemsg[port]->getType()=='t')
                                              {
                                                  cout<<simTime()<<"s:Added to Tail["<<this->getParentModule()->getIndex()<<"]["<<port<<"]["<<vc[port]<<"]:"<<somemsg[port]->getPid()<<"\n";
                                                  buff_tail[this->getParentModule()->getIndex()][port][vc[port]].push(somemsg[port]->getPid());
                                                  somemsg[port] = nullptr;
                                                  delete somemsg[port];
                                                  buffer[this->getParentModule()->getIndex()][port].erase(iter);
                                                  sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);     //TODO: Check if needed to send ack
                                                  return;
                                              }
                                              else
                                              {
                                                  cout<<"Not Possible\n";
                                              }
//                                            ack[port] = false;
//                                            sendDelayed(somemsg[port],k[this->getIndex()]/* (double)(intuniform(0,k)/100.0)*/,"out",port);
//                                            somemsg[port] = nullptr;
//                                            delete somemsg[port];
//                                            sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
//                                            buffer[this->getParentModule()->getIndex()][port].erase(iter);
                                        }
                                    }
                                    break;
                                }
                                iter++;
                            }
                        }
                    }
              }
              else
              {
                  if((ack[port]==true) && ((simTime() - current_time[port]) >= time_slot) && (somemsg[port]!=nullptr) && ((replyfrombooksim = replyfromBookSim(port)) >= 0) )
                  {
//                              cout<<"-Acknowledgement["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->ID("<<somemsg[port]->getPid()<<")\n";
//                                  current_time[port] = simTime();
                              Packet *ack_msg= new Packet();
                                ack_msg->setPid(somemsg[port]->getPid());
                                ack_msg->setPacket_type(1);
                                ack_msg->setKind(1);
                              current_time[port] = simTime();
                              ack[port] = false;
                              sendDelayed(somemsg[port],k[this->getIndex()]/* (double)(intuniform(0,k)/100.0)*/,"out",port);
                              sendDelayed(ack_msg,0.0/* (double)(intuniform(0,k)/100.0)*/,"Ack_out",port/*0*/);
                              somemsg[port] = nullptr;
                              delete somemsg[port];
                  }
              }
              if(!msg->isSelfMessage())
              {
                  if(this->getIndex()==0)
                  {
                      if((buffer[this->getParentModule()->getIndex()][0].size()>0) || (buffer[this->getParentModule()->getIndex()][1].size()>0) ||(buffer[this->getParentModule()->getIndex()][2].size()>0) ||(buffer[this->getParentModule()->getIndex()][3].size()>0) ||(buffer[this->getParentModule()->getIndex()][4].size()>0))
                      {
                          if((int)(getcontrollertime().dbl()) != (int)(simTime().dbl()))
                          {
//                              EV<<"RESET----\n";
                                for(int R=0;R<numRouters;R++)
                                {
                                    for(int C=0;C<numClients;C++)
                                    {
                                            setmsg(true,R,C);
                                    }
                                }
                              setcontrollertime(simTime());
                              cMessage *tt_msg = new cMessage();
                              tt_msg->setKind(4);
                              sendDelayed(tt_msg,0.0,"poll");
                          }
//                          if(getmsg(this->getParentModule()->getIndex(),this->getIndex())==true)
//                          {
//                              EV<<"1-["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]\n";
                              timer_msg = new cMessage();
                              scheduleAt(simTime() + 1.0 /*+ time_slot + double(intuniform(0, 100))/100.0*/ , timer_msg);
                              setmsg(false,this->getParentModule()->getIndex(),this->getIndex());
//                          }
                      }
                  }
                  else
                  {
                      if(somemsg[0] || somemsg[1] ||somemsg[2] ||somemsg[3] ||somemsg[4])
                        {
                            if((int)(getcontrollertime().dbl()) != (int)(simTime().dbl()))
                            {
//                                EV<<"RESET----\n";
                                  for(int R=0;R<numRouters;R++)
                                  {
                                      for(int C=0;C<numClients;C++)
                                      {
                                              setmsg(true,R,C);
                                      }
                                  }
                                setcontrollertime(simTime());
                                cMessage *tt_msg = new cMessage();
                                tt_msg->setKind(4);
                                sendDelayed(tt_msg,0.0,"poll");
                            }
                            if(getmsg(this->getParentModule()->getIndex(),this->getIndex())==true)
                              {
//                                  EV<<"2-["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]\n";
                                  timer_msg = new cMessage();
                                  scheduleAt(simTime() + 1.0 /*+ time_slot + double(intuniform(0, 100))/100.0*/ , timer_msg);
                                  setmsg(false,this->getParentModule()->getIndex(),this->getIndex());
                              }
                        }
                  }
              }
        }
        if(msg->isSelfMessage())
        {
            if(this->getIndex()==0)
              {
                  if((buffer[this->getParentModule()->getIndex()][0].size()>0) || (buffer[this->getParentModule()->getIndex()][1].size()>0) ||(buffer[this->getParentModule()->getIndex()][2].size()>0) ||(buffer[this->getParentModule()->getIndex()][3].size()>0) ||(buffer[this->getParentModule()->getIndex()][4].size()>0))
                  {
                      if((int)(getcontrollertime().dbl()) != (int)(simTime().dbl()))
                      {
//                          EV<<"RESET----\n";
                          for(int R=0;R<numRouters;R++)
                          {
                              for(int C=0;C<numClients;C++)
                              {
                                      setmsg(true,R,C);
                              }
                          }
                          setcontrollertime(simTime());
                          cMessage *tt_msg = new cMessage();
                          tt_msg->setKind(4);
                          sendDelayed(tt_msg,0.0,"poll");
                      }
//                      if(getmsg(this->getParentModule()->getIndex(),this->getIndex())==true)
//                        {
//                            EV<<"3-["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]\n";
                            timer_msg = new cMessage();
                            scheduleAt(simTime() + 1.0 /*+ time_slot + double(intuniform(0, 100))/100.0*/ , timer_msg);
                            setmsg(false,this->getParentModule()->getIndex(),this->getIndex());
//                        }
                  }
              }
              else
              {
                  if(somemsg[0] || somemsg[1] ||somemsg[2] ||somemsg[3] ||somemsg[4])
                    {
                        if((int)(getcontrollertime().dbl()) != (int)(simTime().dbl()))
                        {
//                            EV<<"RESET----\n";
                              for(int R=0;R<numRouters;R++)
                              {
                                  for(int C=0;C<numClients;C++)
                                  {
                                          setmsg(true,R,C);
                                  }
                              }
                            setcontrollertime(simTime());
                            cMessage *tt_msg = new cMessage();
                            tt_msg->setKind(4);
                            sendDelayed(tt_msg,0.0,"poll");
                        }
                        if(getmsg(this->getParentModule()->getIndex(),this->getIndex())==true)
                          {
//                              EV<<"4-["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]\n";
                              timer_msg = new cMessage();
                              scheduleAt(simTime() + 1.0 /*+ time_slot + double(intuniform(0, 100))/100.0*/ , timer_msg);
                              setmsg(false,this->getParentModule()->getIndex(),this->getIndex());
                          }
                    }
              }
        }
        if(msg->isSelfMessage())
        {
            msg=nullptr;
            delete msg;
        }
}

void mod::init_socket()
{
    int R,C,P;
    for(R=0;R<numRouters;R++)
    {
        for(C=0;C<numClients;C++)
        {
            for(P=0;P<5;P++)
            {
                fp[R][C][P] = fdopen(getfd(R,C,P), "r");
                fds[R][C][P].fd = getfd(R,C,P);                  //FDS-Client
                fds[R][C][P].events = POLLIN;
            }
        }
    }
//        //Toy
//    for(R=0;R<numRouters;R++)
//       {
//           for(C=0;C<numClients;C++)
//           {
//               for(P=0;P<5;P++)
//               {
//                   fp2[R][C][P] = fdopen(getfd2(R,C,P), "r");  //Toy
//                   fds2[R][C][P].fd = getfd2(R,C,P);    //Toy                //FDS-Client
//                   fds2[R][C][P].events = POLLIN;  //Toy
//
//               }
//           }
//       }
}


int mod::replyfromBookSim(int port)
{
    int rv,output=0;
    rv = poll(&fds[this->getParentModule()->getIndex()][this->getIndex()][port],1,0);
    if(rv > 0)
    {
        while ((c = fgetc(fp[this->getParentModule()->getIndex()][this->getIndex()][port])) != EOF)
        {
            if (c == '\n')
                break;
            else
                output = output*10 + (c - 48);//int(c) - 48;
        }
    }
    if((this->getIndex() == 3) && (rv > 0))
    {
//        cout<<simTime()<<"s:Recv(.5.):["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->"<<output<<"<-\n";
          return output;
    }
    else if((this->getIndex() == 0) && (rv > 0))
    {
        int output1=0;
        int id = -1;
//        output=-1;
        while ((c = fgetc(fp[this->getParentModule()->getIndex()][this->getIndex()][port])) != EOF)
        {
            if (c == '\n')
            {
//                cout<<simTime()<<"s:Recv:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->"<<output<<"<-\n";
                buff_reply[this->getParentModule()->getIndex()][port].push(make_pair(output,output1));
                output1=0;
                break;
            }
            else
                output1 = output1*10 + (c - 48);//int(c) - 48;
        }
        while ((c = fgetc(fp[this->getParentModule()->getIndex()][this->getIndex()][port])) != '*')
        {
            if (c == '\n')
            {
                if(id==-1)
                    id=output1;
                else
                {
//                    cout<<simTime()<<"s:Recv:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->"<<id<<"<-\n";
                    buff_reply[this->getParentModule()->getIndex()][port].push(make_pair(id,output1));
                    id=-1;
                }
                output1=0;
            }
            else
                output1 = output1*10 + (c - 48);//int(c) - 48;
        }
        return -1;
    }
    else
    {
            return (rv-1);
    }
}

void mod::notifyBookSim( int id, int port )
{
//            cout<<simTime()<<"s: R,C,P:["<<this->getParentModule()->getIndex()<<"]["<<this->getIndex()<<"]["<<port<<"]->ID:"<<id<<"\n";
        std::string myvariable_router = patch::to_string(id);
        myvariable_router.append("\n");
        str_tbs = &myvariable_router[0];
        ::send(getfd(this->getParentModule()->getIndex(),this->getIndex(),port), str_tbs, strlen(str_tbs),0);
//        ::send(getfd2(this->getParentModule()->getIndex(),this->getIndex(),port), str_tbs, strlen(str_tbs),0);
        if(this->getIndex()==0 || this->getIndex()==3)
        {
            sethasvalue(true,this->getParentModule()->getIndex(),this->getIndex(),port);
        }
}

void mod::finish()
{
//    delete timer_msg;
//    close(s);
//    EV<<"finishing the simulation\n";
}
